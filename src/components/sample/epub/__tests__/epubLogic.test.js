// src/components/sample/epub/__tests__/epubLogic.test.js
//
// Jest unit/regression tests for epubLogic.js
//
// These tests load JSON snapshots generated by extractEpubSnapshot.mjs
// and verify that the UI pipeline (dedupe -> prepend -> score -> collapse)
// remains stable.

import fs from "fs";
import path from "path";

import {
  computeEpubStructureScore,
  shouldCollapseToSingleSection,
  collapseToSingleSectionPreserveFrontmatter,
  prependMissingSpineSections,
  dedupeTocBySpineHref,
} from "../epubLogic";

const SNAP_DIR = path.join(__dirname, "fixtures", "snapshots");

function listSnapshotFiles() {
  if (!fs.existsSync(SNAP_DIR)) return [];
  return fs
    .readdirSync(SNAP_DIR)
    .filter((f) => f.toLowerCase().endsWith(".json"))
    .map((f) => path.join(SNAP_DIR, f))
    .sort();
}

function loadSnapshot(filePath) {
  const raw = fs.readFileSync(filePath, "utf8");
  return JSON.parse(raw);
}

function createMockBookFromSnapshot(snapshot) {
  const spineItems = (snapshot?.spine || []).map((it, idx) => ({
    href: it?.href || null,
    idref: it?.idref || null,
    properties: it?.properties || null,
    linear: it?.linear ?? null,
    index: typeof it?.index === "number" ? it.index : idx,
  }));

  // Build a map for spine.get(href) lookups
  const map = new Map();
  spineItems.forEach((it, idx) => {
    if (!it?.href) return;

    map.set(String(it.href), { index: idx });
    map.set(String(it.href).split("#")[0].split("?")[0], { index: idx });

    const fileName = String(it.href).split("/").pop();
    if (fileName) map.set(fileName, { index: idx });

    // Also store without common prefixes (OPS/, OEBPS/, etc.)
    const p = String(it.href);
    const prefixes = ["OPS/", "OEBPS/", "EPUB/", "Text/", "XHTML/", "xhtml/"];
    for (const pref of prefixes) {
      if (p.startsWith(pref)) map.set(p.slice(pref.length), { index: idx });
    }
  });

  const book = {
    spine: {
      spineItems,
      get: (href) => {
        if (!href) return null;
        const key = String(href);

        // Try direct
        if (map.has(key)) return map.get(key);

        // Try stripped
        const noFrag = key.split("#")[0].split("?")[0];
        if (map.has(noFrag)) return map.get(noFrag);

        // Try filename
        const fileName = noFrag.split("/").pop();
        if (fileName && map.has(fileName)) return map.get(fileName);

        // Try removing prefixes
        const prefixes = [
          "OPS/",
          "OEBPS/",
          "EPUB/",
          "Text/",
          "XHTML/",
          "xhtml/",
        ];
        for (const pref of prefixes) {
          if (noFrag.startsWith(pref)) {
            const cut = noFrag.slice(pref.length);
            if (map.has(cut)) return map.get(cut);
          }
        }

        return null;
      },
    },
  };

  return book;
}

function runUiPipeline(book, tocRaw) {
  const deduped = dedupeTocBySpineHref(book, tocRaw);
  const withFront = prependMissingSpineSections(book, deduped);
  const score = computeEpubStructureScore(book, withFront);
  const collapse = shouldCollapseToSingleSection(book, withFront);

  const finalToc = collapse
    ? collapseToSingleSectionPreserveFrontmatter(book, withFront)
    : withFront;

  return { deduped, withFront, score, collapse, finalToc };
}

function normalizeLabels(arr) {
  return (arr || []).map((x) => String(x?.label || "").trim()).filter(Boolean);
}

describe("epubLogic â€“ snapshot regression (UI pipeline)", () => {
  const files = listSnapshotFiles();

  test("snapshots directory exists and has snapshots", () => {
    expect(fs.existsSync(SNAP_DIR)).toBe(true);
    expect(files.length).toBeGreaterThan(0);
  });

  test.each(files.map((p) => [path.basename(p), p]))(
    "score shape is sane: %s",
    (_, filePath) => {
      const snap = loadSnapshot(filePath);
      const book = createMockBookFromSnapshot(snap);

      const tocRaw =
        (snap?.pipeline?.tocRaw || snap?.tocFlat || []).map((x) => ({
          href: x.href,
          label: x.label,
        })) || [];

      const { score } = runUiPipeline(book, tocRaw);

      expect(score).toBeTruthy();
      expect(["chapter", "fallback"]).toContain(score.mode);
      expect(typeof score.score).toBe("number");
      expect(score.score).toBeGreaterThanOrEqual(0);
      expect(score.score).toBeLessThanOrEqual(100);

      expect(Array.isArray(score.reasons)).toBe(true);
      expect(score.metrics).toBeTruthy();
      expect(typeof score.metrics.spineLen).toBe("number");
      expect(typeof score.metrics.tocLen).toBe("number");
    }
  );

  test.each(files.map((p) => [path.basename(p), p]))(
    "mode matches snapshot heuristics: %s",
    (_, filePath) => {
      const snap = loadSnapshot(filePath);
      const expected = snap?.heuristics?.structure?.mode || null;

      // If the snapshot predates v3 pipeline fields, we skip pinning.
      if (!expected) {
        expect(true).toBe(true);
        return;
      }

      const book = createMockBookFromSnapshot(snap);

      const tocRaw =
        (snap?.pipeline?.tocRaw || snap?.tocFlat || []).map((x) => ({
          href: x.href,
          label: x.label,
        })) || [];

      const { score } = runUiPipeline(book, tocRaw);
      expect(score.mode).toBe(expected);
    }
  );

  test.each(files.map((p) => [path.basename(p), p]))(
    "collapse decision matches snapshot: %s",
    (_, filePath) => {
      const snap = loadSnapshot(filePath);

      // v3 snapshots have heuristics.collapse
      if (typeof snap?.heuristics?.collapse !== "boolean") {
        expect(true).toBe(true);
        return;
      }

      const book = createMockBookFromSnapshot(snap);

      const tocRaw =
        (snap?.pipeline?.tocRaw || snap?.tocFlat || []).map((x) => ({
          href: x.href,
          label: x.label,
        })) || [];

      const { collapse } = runUiPipeline(book, tocRaw);
      expect(collapse).toBe(snap.heuristics.collapse);
    }
  );

  test.each(files.map((p) => [path.basename(p), p]))(
    "fallback/collapse preserves frontmatter + adds Indhold (tolerant labels): %s",
    (_, filePath) => {
      const snap = loadSnapshot(filePath);

      // Only run this assertion when snapshot says collapse/fallback
      const should =
        snap?.heuristics?.structure?.mode === "fallback" ||
        snap?.heuristics?.collapse === true;

      if (!should) {
        expect(true).toBe(true);
        return;
      }

      const book = createMockBookFromSnapshot(snap);

      const tocRaw =
        (snap?.pipeline?.tocRaw || snap?.tocFlat || []).map((x) => ({
          href: x.href,
          label: x.label,
        })) || [];

      const { finalToc } = runUiPipeline(book, tocRaw);
      const labels = normalizeLabels(finalToc);

      // Must have Indhold in collapsed mode
      expect(labels).toContain("Indhold");

      // Best-effort frontmatter: accept either DK or EN-ish variants
      const hasCoverLike = labels.some(
        (l) => /^forside$/i.test(l) || /^cover$/i.test(l)
      );
      if (hasCoverLike) {
        expect(
          labels.some((l) => /^forside$/i.test(l) || /^cover$/i.test(l))
        ).toBe(true);
      }

      const hasTitleLike = labels.some(
        (l) =>
          /^titelblad$/i.test(l) || /^title$/i.test(l) || /^titel$/i.test(l)
      );
      if (hasTitleLike) {
        expect(
          labels.some(
            (l) =>
              /^titelblad$/i.test(l) || /^title$/i.test(l) || /^titel$/i.test(l)
          )
        ).toBe(true);
      }

      const hasColophonLike = labels.some(
        (l) =>
          /^kolofon$/i.test(l) ||
          /^colophon$/i.test(l) ||
          /^copyright$/i.test(l)
      );
      if (hasColophonLike) {
        expect(
          labels.some(
            (l) =>
              /^kolofon$/i.test(l) ||
              /^colophon$/i.test(l) ||
              /^copyright$/i.test(l)
          )
        ).toBe(true);
      }
    }
  );
});
