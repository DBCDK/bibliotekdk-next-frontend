// src/components/sample/epub/__tests__/epubLogic.test.js
//
// Jest unit/regression tests for epubLogic.js
//
// These tests load JSON snapshots generated by extractEpubSnapshot.mjs
// and verify that structure scoring + fallback behavior remains stable.

import fs from "fs";
import path from "path";

import {
  computeEpubStructureScore,
  shouldCollapseToSingleSection,
  collapseToSingleSectionPreserveFrontmatter,
  prependMissingSpineSections,
} from "../epubLogic";

const SNAP_DIR = path.join(__dirname, "fixtures", "snapshots");

function listSnapshotFiles() {
  if (!fs.existsSync(SNAP_DIR)) return [];
  return fs
    .readdirSync(SNAP_DIR)
    .filter((f) => f.toLowerCase().endsWith(".json"))
    .map((f) => path.join(SNAP_DIR, f))
    .sort();
}

function loadSnapshot(filePath) {
  const raw = fs.readFileSync(filePath, "utf8");
  return JSON.parse(raw);
}

function createMockBookFromSnapshot(snapshot) {
  const spineItems = (snapshot?.spine || []).map((it) => ({
    href: it?.href || null,
    idref: it?.idref || null,
    properties: it?.properties || null,
    linear: it?.linear ?? null,
  }));

  // Build a map for spine.get(href) lookups
  // We'll match both exact and stripped paths, since epubLogic tries multiple candidates.
  const map = new Map();
  spineItems.forEach((it, idx) => {
    if (!it?.href) return;
    map.set(String(it.href), { index: idx });
    // also store filename-only key
    const fileName = String(it.href).split("/").pop();
    if (fileName) map.set(fileName, { index: idx });
  });

  const book = {
    spine: {
      spineItems,
      get: (href) => {
        if (!href) return null;
        const key = String(href);
        const hit = map.get(key);
        if (hit) return hit;

        // Also try stripping leading prefixes to simulate epubjs behavior
        const noFrag = key.split("#")[0].split("?")[0];
        const fileName = noFrag.split("/").pop();
        if (fileName && map.has(fileName)) return map.get(fileName);

        return null;
      },
    },
  };

  return book;
}

function detectFrontmatterBySpine(snapshot) {
  const spine = snapshot?.spine || [];
  const hasCover = spine.some(
    (x) =>
      /cover/i.test(String(x?.href || "")) ||
      /\bcover\b/i.test(String(x?.properties || ""))
  );
  const hasTitle = spine.some(
    (x) =>
      /(title|titel|titelblad|titlepage)/i.test(String(x?.href || "")) ||
      /(title|titel)/i.test(String(x?.idref || ""))
  );
  const hasColophon = spine.some(
    (x) =>
      /(colophon|kolofon|copyright)/i.test(String(x?.href || "")) ||
      /(colophon|kolofon|copyright)/i.test(String(x?.idref || ""))
  );
  return { hasCover, hasTitle, hasColophon };
}

describe("epubLogic â€“ snapshot regression", () => {
  const files = listSnapshotFiles();

  test("snapshots directory exists and has snapshots", () => {
    expect(fs.existsSync(SNAP_DIR)).toBe(true);
    expect(files.length).toBeGreaterThan(0);
  });

  test.each(files.map((p) => [path.basename(p), p]))(
    "score shape + stability: %s",
    (_, filePath) => {
      const snap = loadSnapshot(filePath);
      const book = createMockBookFromSnapshot(snap);

      const tocFlat = (snap?.tocFlat || []).map((x) => ({
        href: x.href,
        label: x.label,
      }));
      const score = computeEpubStructureScore(book, tocFlat);

      expect(score).toBeTruthy();
      expect(["chapter", "fallback"]).toContain(score.mode);
      expect(typeof score.score).toBe("number");
      expect(score.score).toBeGreaterThanOrEqual(0);
      expect(score.score).toBeLessThanOrEqual(100);
      expect(Array.isArray(score.reasons)).toBe(true);
      expect(score.metrics).toBeTruthy();
      expect(typeof score.metrics.spineLen).toBe("number");
      expect(typeof score.metrics.tocLen).toBe("number");
    }
  );

  test.each(files.map((p) => [path.basename(p), p]))(
    "fallback preserves frontmatter when present: %s",
    (_, filePath) => {
      const snap = loadSnapshot(filePath);
      const book = createMockBookFromSnapshot(snap);

      const tocFlat = (snap?.tocFlat || []).map((x) => ({
        href: x.href,
        label: x.label,
      }));

      // Our normal pipeline in useEpubReader:
      // filtered -> prependMissingSpineSections -> maybe collapse
      const withFront = prependMissingSpineSections(book, tocFlat);
      const collapse = shouldCollapseToSingleSection(book, withFront);

      if (!collapse) {
        // not a fallback case; nothing to assert here
        expect(true).toBe(true);
        return;
      }

      const collapsed = collapseToSingleSectionPreserveFrontmatter(
        book,
        withFront
      );
      const labels = collapsed.map((x) => String(x?.label || ""));

      const fm = detectFrontmatterBySpine(snap);

      // Cover should almost always map to "Forside" when present
      if (fm.hasCover) expect(labels).toContain("Forside");

      // Title + colophon are best-effort; assert when spine strongly indicates them
      if (fm.hasTitle) expect(labels).toContain("Titelblad");
      if (fm.hasColophon) expect(labels).toContain("Kolofon");

      // Must always end with "Indhold" in fallback mode
      expect(labels).toContain("Indhold");
    }
  );

  test("known behaviors (optional): can pin specific books to modes", () => {
    // If you want stronger regression, pin some ISBNs here.
    // These assertions are safe even if snapshots are missing; the test just won't run them.
    const expectations = {
      // page-like / noisy TOC => fallback:
      "9788702421484.json": "fallback",
      // prolog example (typically real TOC) => chapter:
      "9788740028621.json": "chapter",
    };

    for (const [fileName, expectedMode] of Object.entries(expectations)) {
      const filePath = path.join(SNAP_DIR, fileName);
      if (!fs.existsSync(filePath)) continue;

      const snap = loadSnapshot(filePath);
      const book = createMockBookFromSnapshot(snap);
      const tocFlat = (snap?.tocFlat || []).map((x) => ({
        href: x.href,
        label: x.label,
      }));

      const withFront = prependMissingSpineSections(book, tocFlat);
      const score = computeEpubStructureScore(book, withFront);

      expect(score.mode).toBe(expectedMode);
    }
  });
});
