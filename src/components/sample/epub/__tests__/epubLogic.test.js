// src/components/sample/epub/__tests__/epubLogic.test.js
//
// Jest unit/regression tests for epubLogic.js
//
// These tests load JSON snapshots generated by extractEpubSnapshot.mjs
// and verify that UI pipeline behavior remains stable.

import fs from "fs";
import path from "path";

import {
  computeEpubStructureScore,
  shouldCollapseToSingleSection,
  collapseToSingleSectionPreserveFrontmatter,
  prependMissingSpineSections,
  dedupeTocBySpineHref,
  stripHashQuery,
} from "../epubLogic";

const SNAP_DIR = path.join(__dirname, "fixtures", "snapshots");

function listSnapshotFiles() {
  if (!fs.existsSync(SNAP_DIR)) return [];
  return fs
    .readdirSync(SNAP_DIR)
    .filter((f) => f.toLowerCase().endsWith(".json"))
    .map((f) => path.join(SNAP_DIR, f))
    .sort();
}

function loadSnapshot(filePath) {
  const raw = fs.readFileSync(filePath, "utf8");
  return JSON.parse(raw);
}

function createMockBookFromSnapshot(snapshot) {
  const spineItems = (snapshot?.spine || []).map((it, idx) => ({
    href: it?.href || null,
    idref: it?.idref || null,
    properties: it?.properties || null,
    linear: it?.linear ?? null,
    index: typeof it?.index === "number" ? it.index : idx,
  }));

  const map = new Map();
  spineItems.forEach((it, idx) => {
    if (!it?.href) return;

    // exact
    map.set(String(it.href), { index: idx });

    // no-frag
    map.set(stripHashQuery(String(it.href)), { index: idx });

    // filename-only
    const fileName = String(it.href).split("/").pop();
    if (fileName) map.set(fileName, { index: idx });
  });

  return {
    spine: {
      spineItems,
      get: (href) => {
        if (!href) return null;
        const key = String(href);

        // try exact + stripped + filename
        const hit =
          map.get(key) ||
          map.get(stripHashQuery(key)) ||
          map.get(stripHashQuery(key).split("/").pop());
        return hit || null;
      },
    },
  };
}

function runUiPipeline(book, tocRaw) {
  const deduped = dedupeTocBySpineHref(book, tocRaw);
  const withFront = prependMissingSpineSections(book, deduped);
  const score = computeEpubStructureScore(book, withFront);
  const collapse = shouldCollapseToSingleSection(book, withFront);

  const tocFinal = collapse
    ? collapseToSingleSectionPreserveFrontmatter(book, withFront)
    : withFront;

  return { deduped, withFront, score, collapse, tocFinal };
}

describe("epubLogic â€“ snapshot regression (UI pipeline)", () => {
  const files = listSnapshotFiles();

  test("snapshots directory exists and has snapshots", () => {
    expect(fs.existsSync(SNAP_DIR)).toBe(true);
    expect(files.length).toBeGreaterThan(0);
  });

  test.each(files.map((p) => [path.basename(p), p]))(
    "score shape: %s",
    (_, filePath) => {
      const snap = loadSnapshot(filePath);
      const book = createMockBookFromSnapshot(snap);

      const tocRaw = (snap?.tocFlat || []).map((x) => ({
        href: x.href,
        label: x.label,
      }));

      const { score } = runUiPipeline(book, tocRaw);

      expect(score).toBeTruthy();
      expect(["chapter", "fallback"]).toContain(score.mode);
      expect(typeof score.score).toBe("number");
      expect(score.score).toBeGreaterThanOrEqual(0);
      expect(score.score).toBeLessThanOrEqual(150); // we allow internal score > 100 (we clamp in UI if needed)
      expect(Array.isArray(score.reasons)).toBe(true);
      expect(score.metrics).toBeTruthy();
      expect(typeof score.metrics.spineLen).toBe("number");
      expect(typeof score.metrics.tocLen).toBe("number");
    }
  );

  test.each(files.map((p) => [path.basename(p), p]))(
    "mode matches snapshot heuristics: %s",
    (_, filePath) => {
      const snap = loadSnapshot(filePath);
      const expectedMode = snap?.heuristics?.structure?.mode;
      if (!expectedMode) {
        // Snapshot may be older / missing heuristics.
        expect(true).toBe(true);
        return;
      }

      const book = createMockBookFromSnapshot(snap);
      const tocRaw = (snap?.tocFlat || []).map((x) => ({
        href: x.href,
        label: x.label,
      }));

      const { score } = runUiPipeline(book, tocRaw);
      expect(score.mode).toBe(expectedMode);
    }
  );

  test.each(files.map((p) => [path.basename(p), p]))(
    "collapse decision matches snapshot: %s",
    (_, filePath) => {
      const snap = loadSnapshot(filePath);
      const expectedCollapse =
        typeof snap?.heuristics?.collapse === "boolean"
          ? snap.heuristics.collapse
          : typeof snap?.pipeline?.collapse === "boolean"
          ? snap.pipeline.collapse
          : null;

      if (expectedCollapse == null) {
        // Snapshot missing collapse info
        expect(true).toBe(true);
        return;
      }

      const book = createMockBookFromSnapshot(snap);
      const tocRaw = (snap?.tocFlat || []).map((x) => ({
        href: x.href,
        label: x.label,
      }));

      const { collapse } = runUiPipeline(book, tocRaw);
      expect(collapse).toBe(expectedCollapse);
    }
  );

  test.each(files.map((p) => [path.basename(p), p]))(
    "fallback final toc includes Indhold and keeps Forside when present: %s",
    (_, filePath) => {
      const snap = loadSnapshot(filePath);
      const expectedMode = snap?.heuristics?.structure?.mode;
      if (expectedMode !== "fallback") {
        expect(true).toBe(true);
        return;
      }

      const book = createMockBookFromSnapshot(snap);
      const tocRaw = (snap?.tocFlat || []).map((x) => ({
        href: x.href,
        label: x.label,
      }));

      const { tocFinal, score } = runUiPipeline(book, tocRaw);
      expect(score.mode).toBe("fallback");

      const labels = tocFinal.map((x) => String(x?.label || ""));

      // Must contain Indhold in fallback
      expect(labels).toContain("Indhold");

      // If spine suggests cover, we usually keep Forside
      const spine = snap?.spine || [];
      const hasCover = spine.some(
        (x) =>
          /cover/i.test(String(x?.href || "")) ||
          /\bcover\b/i.test(String(x?.properties || ""))
      );
      if (hasCover) expect(labels).toContain("Forside");
    }
  );
});
